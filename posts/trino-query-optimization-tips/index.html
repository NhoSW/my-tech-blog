<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Trino Query Optimization: Practical Tips for Better Performance | OTL - Data Engineering</title><meta name=keywords content="trino,sql,optimization,performance"><meta name=description content="Practical tips for optimizing Trino queries in production. Covers partition pruning, join strategies, data types, and query profiling techniques."><meta name=author content="Seungwoo Noh"><link rel=canonical href=https://NhoSW.github.io/my-tech-blog/posts/trino-query-optimization-tips/><link crossorigin=anonymous href=/my-tech-blog/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://NhoSW.github.io/my-tech-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://NhoSW.github.io/my-tech-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://NhoSW.github.io/my-tech-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://NhoSW.github.io/my-tech-blog/apple-touch-icon.png><link rel=mask-icon href=https://NhoSW.github.io/my-tech-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://NhoSW.github.io/my-tech-blog/posts/trino-query-optimization-tips/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XXXXXXXXXX")}</script><meta property="og:url" content="https://NhoSW.github.io/my-tech-blog/posts/trino-query-optimization-tips/"><meta property="og:site_name" content="OTL - Data Engineering"><meta property="og:title" content="Trino Query Optimization: Practical Tips for Better Performance"><meta property="og:description" content="Practical tips for optimizing Trino queries in production. Covers partition pruning, join strategies, data types, and query profiling techniques."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-23T00:00:00+00:00"><meta property="article:modified_time" content="2026-02-23T00:00:00+00:00"><meta property="article:tag" content="Trino"><meta property="article:tag" content="Sql"><meta property="article:tag" content="Optimization"><meta property="article:tag" content="Performance"><meta name=twitter:card content="summary"><meta name=twitter:title content="Trino Query Optimization: Practical Tips for Better Performance"><meta name=twitter:description content="Practical tips for optimizing Trino queries in production. Covers partition pruning, join strategies, data types, and query profiling techniques."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://NhoSW.github.io/my-tech-blog/posts/"},{"@type":"ListItem","position":2,"name":"Trino Query Optimization: Practical Tips for Better Performance","item":"https://NhoSW.github.io/my-tech-blog/posts/trino-query-optimization-tips/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Trino Query Optimization: Practical Tips for Better Performance","name":"Trino Query Optimization: Practical Tips for Better Performance","description":"Practical tips for optimizing Trino queries in production. Covers partition pruning, join strategies, data types, and query profiling techniques.","keywords":["trino","sql","optimization","performance"],"articleBody":"Trino is a powerful distributed SQL engine, but throwing queries at it without thinking about how it executes them is a fast track to slow dashboards, failed queries, and frustrated stakeholders. After running Trino in production against multi-terabyte data lakes for several years, I have collected a set of optimization patterns that consistently make a real difference. This post covers the ones I reach for most often.\n1. Partition Pruning and Predicate Pushdown The single highest-impact optimization is making sure Trino reads as little data as possible. If your tables are partitioned – and they should be – always filter on the partition column explicitly.\nBad – full table scan:\nSELECT user_id, event_type, created_at FROM hive.analytics.events WHERE created_at \u003e= TIMESTAMP '2026-01-01 00:00:00'; If dt is the partition column (a date string like 2026-01-15) and created_at is a timestamp column inside the data files, Trino cannot use the created_at filter to skip partitions. It has to open every partition and scan.\nOptimized – partition column in the WHERE clause:\nSELECT user_id, event_type, created_at FROM hive.analytics.events WHERE dt \u003e= '2026-01-01' AND created_at \u003e= TIMESTAMP '2026-01-01 00:00:00'; Adding the dt predicate lets Trino prune partitions at the metastore level before reading a single byte of data. I have seen this alone reduce query times from 10+ minutes to under 30 seconds.\nThe same principle applies to predicate pushdown into connectors. Filters on columns that exist in file-level metadata (Parquet min/max statistics, for example) allow Trino to skip entire row groups. Keep your predicates simple and on the columns the storage layer knows about.\n2. Join Optimization Trino supports two join distribution strategies: broadcast and partitioned (distributed). The choice matters enormously.\nBroadcast join: The smaller table is copied to every worker node. Great when one side is small (\u003c a few hundred MB). Distributed join: Both sides are hash-partitioned across workers. Required when both tables are large. Trino’s cost-based optimizer usually picks well, but when statistics are stale or absent, it guesses wrong. You can guide it:\n-- Force a broadcast join when you know the dimension table is small SELECT /*+ BROADCAST(d) */ f.order_id, f.amount, d.region_name FROM hive.warehouse.fact_orders f JOIN hive.warehouse.dim_regions d ON f.region_id = d.region_id; Join ordering also matters. Filter early, join late. Push filters and aggregations as close to the base tables as possible so that intermediate result sets are small before they hit the join.\nBad – join first, filter later:\nSELECT o.order_id, o.amount, c.segment FROM orders o JOIN customers c ON o.customer_id = c.customer_id WHERE o.dt = '2026-02-01' AND c.segment = 'enterprise'; Better – pre-filter with CTEs for clarity and to help the optimizer:\nWITH filtered_orders AS ( SELECT order_id, amount, customer_id FROM orders WHERE dt = '2026-02-01' ), enterprise_customers AS ( SELECT customer_id, segment FROM customers WHERE segment = 'enterprise' ) SELECT o.order_id, o.amount, c.segment FROM filtered_orders o JOIN enterprise_customers c ON o.customer_id = c.customer_id; In practice, Trino’s optimizer can often push predicates down through joins on its own. But making the intent explicit with CTEs both helps readability and gives the planner a clearer picture, especially in complex multi-join queries.\n3. Data Type and Format Considerations Your file format and schema design decisions are made long before query time, but they have a direct impact on performance.\nUse columnar formats. Parquet and ORC both support column projection and predicate pushdown via min/max statistics. Avoid JSON and CSV for analytical tables. Select only the columns you need. With columnar formats, every column you add to your SELECT is an additional I/O cost. Bad:\nSELECT * FROM hive.analytics.events WHERE dt = '2026-02-01'; Optimized:\nSELECT user_id, event_type, created_at FROM hive.analytics.events WHERE dt = '2026-02-01'; This is basic, but I still see SELECT * in production dashboards that read 200-column tables when only 4 columns are used. On a wide Parquet table the difference can be 10-20x in I/O.\nAlso watch your data types. Joining on a VARCHAR column when both sides could be BIGINT adds unnecessary overhead from hashing and comparison. If you control the pipeline, cast to the most efficient type upstream.\n4. Query Profiling with EXPLAIN and Query Stats Before optimizing blindly, measure. Trino gives you two essential tools:\nEXPLAIN shows the logical and distributed plan:\nEXPLAIN SELECT user_id, COUNT(*) AS cnt FROM hive.analytics.events WHERE dt = '2026-02-01' GROUP BY user_id; Look for ScanFilterProject to verify predicate pushdown is happening. Check whether the join strategy is REPLICATED (broadcast) or PARTITIONED (distributed). If the plan shows a full TableScan with no filter, your predicates are not being pushed down.\nEXPLAIN ANALYZE actually runs the query and gives you runtime statistics:\nEXPLAIN ANALYZE SELECT user_id, COUNT(*) AS cnt FROM hive.analytics.events WHERE dt = '2026-02-01' GROUP BY user_id; This shows wall time, rows processed, data read per stage, and memory usage. I make it a habit to run EXPLAIN ANALYZE on any new query before it goes into a scheduled pipeline. The Trino Web UI also exposes per-query stats, stage-level timing, and memory breakdowns – all valuable for diagnosing bottlenecks.\n5. Resource Management Tips A single expensive query can starve an entire cluster. A few configuration and usage practices help:\nUse resource groups to isolate workloads. Give ETL pipelines, ad-hoc analysts, and dashboards separate concurrency and memory limits so they do not interfere with each other. Limit concurrent queries per user or group. Even well-optimized queries add up when 50 of them run simultaneously. Set session-level memory limits for exploratory work: SET SESSION query_max_memory = '2GB'; This prevents an accidental cross join from consuming the entire cluster’s memory before it gets killed.\nAvoid ORDER BY without LIMIT on large result sets. Sorting requires materializing the full result in memory. If you just need the top N rows, always add LIMIT. Final Thoughts Most Trino performance wins come from reading less data: prune partitions, select fewer columns, filter early. After that, getting join strategies right and profiling with EXPLAIN ANALYZE covers the majority of remaining issues. None of these tips are exotic – they are fundamentals that compound. Getting them right consistently is what separates a query that finishes in 3 seconds from one that times out.\n","wordCount":"1015","inLanguage":"en","datePublished":"2026-02-23T00:00:00Z","dateModified":"2026-02-23T00:00:00Z","author":{"@type":"Person","name":"Seungwoo Noh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://NhoSW.github.io/my-tech-blog/posts/trino-query-optimization-tips/"},"publisher":{"@type":"Organization","name":"OTL - Data Engineering","logo":{"@type":"ImageObject","url":"https://NhoSW.github.io/my-tech-blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://NhoSW.github.io/my-tech-blog/ accesskey=h title="OTL - Data Engineering (Alt + H)">OTL - Data Engineering</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://NhoSW.github.io/my-tech-blog/ko/ title=한국어 aria-label=한국어>Ko</a></li></ul></div></div><ul id=menu><li><a href=https://NhoSW.github.io/my-tech-blog/ title=Home><span>Home</span></a></li><li><a href=https://NhoSW.github.io/my-tech-blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://NhoSW.github.io/my-tech-blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://NhoSW.github.io/my-tech-blog/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://NhoSW.github.io/my-tech-blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://NhoSW.github.io/my-tech-blog/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://NhoSW.github.io/my-tech-blog/>Home</a>&nbsp;»&nbsp;<a href=https://NhoSW.github.io/my-tech-blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Trino Query Optimization: Practical Tips for Better Performance</h1><div class=post-meta><span title='2026-02-23 00:00:00 +0000 UTC'>February 23, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Seungwoo Noh</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/NhoSW/my-tech-blog/tree/main/content/posts/trino-query-optimization-tips.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-partition-pruning-and-predicate-pushdown aria-label="1. Partition Pruning and Predicate Pushdown">1. Partition Pruning and Predicate Pushdown</a></li><li><a href=#2-join-optimization aria-label="2. Join Optimization">2. Join Optimization</a></li><li><a href=#3-data-type-and-format-considerations aria-label="3. Data Type and Format Considerations">3. Data Type and Format Considerations</a></li><li><a href=#4-query-profiling-with-explain-and-query-stats aria-label="4. Query Profiling with EXPLAIN and Query Stats">4. Query Profiling with EXPLAIN and Query Stats</a></li><li><a href=#5-resource-management-tips aria-label="5. Resource Management Tips">5. Resource Management Tips</a></li><li><a href=#final-thoughts aria-label="Final Thoughts">Final Thoughts</a></li></ul></div></details></div><div class=post-content><p>Trino is a powerful distributed SQL engine, but throwing queries at it without thinking about how it executes them is a fast track to slow dashboards, failed queries, and frustrated stakeholders. After running Trino in production against multi-terabyte data lakes for several years, I have collected a set of optimization patterns that consistently make a real difference. This post covers the ones I reach for most often.</p><h2 id=1-partition-pruning-and-predicate-pushdown>1. Partition Pruning and Predicate Pushdown<a hidden class=anchor aria-hidden=true href=#1-partition-pruning-and-predicate-pushdown>#</a></h2><p>The single highest-impact optimization is making sure Trino reads as little data as possible. If your tables are partitioned &ndash; and they should be &ndash; always filter on the partition column explicitly.</p><p><strong>Bad &ndash; full table scan:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>user_id</span><span class=p>,</span><span class=w> </span><span class=n>event_type</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>hive</span><span class=p>.</span><span class=n>analytics</span><span class=p>.</span><span class=n>events</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=n>created_at</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=k>TIMESTAMP</span><span class=w> </span><span class=s1>&#39;2026-01-01 00:00:00&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>If <code>dt</code> is the partition column (a date string like <code>2026-01-15</code>) and <code>created_at</code> is a timestamp column inside the data files, Trino cannot use the <code>created_at</code> filter to skip partitions. It has to open every partition and scan.</p><p><strong>Optimized &ndash; partition column in the WHERE clause:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>user_id</span><span class=p>,</span><span class=w> </span><span class=n>event_type</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>hive</span><span class=p>.</span><span class=n>analytics</span><span class=p>.</span><span class=n>events</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=n>dt</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=s1>&#39;2026-01-01&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>AND</span><span class=w> </span><span class=n>created_at</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=k>TIMESTAMP</span><span class=w> </span><span class=s1>&#39;2026-01-01 00:00:00&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Adding the <code>dt</code> predicate lets Trino prune partitions at the metastore level before reading a single byte of data. I have seen this alone reduce query times from 10+ minutes to under 30 seconds.</p><p>The same principle applies to predicate pushdown into connectors. Filters on columns that exist in file-level metadata (Parquet min/max statistics, for example) allow Trino to skip entire row groups. Keep your predicates simple and on the columns the storage layer knows about.</p><h2 id=2-join-optimization>2. Join Optimization<a hidden class=anchor aria-hidden=true href=#2-join-optimization>#</a></h2><p>Trino supports two join distribution strategies: <strong>broadcast</strong> and <strong>partitioned (distributed)</strong>. The choice matters enormously.</p><ul><li><strong>Broadcast join:</strong> The smaller table is copied to every worker node. Great when one side is small (&lt; a few hundred MB).</li><li><strong>Distributed join:</strong> Both sides are hash-partitioned across workers. Required when both tables are large.</li></ul><p>Trino&rsquo;s cost-based optimizer usually picks well, but when statistics are stale or absent, it guesses wrong. You can guide it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- Force a broadcast join when you know the dimension table is small
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=cm>/*+ BROADCAST(d) */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>f</span><span class=p>.</span><span class=n>order_id</span><span class=p>,</span><span class=w> </span><span class=n>f</span><span class=p>.</span><span class=n>amount</span><span class=p>,</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>region_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>hive</span><span class=p>.</span><span class=n>warehouse</span><span class=p>.</span><span class=n>fact_orders</span><span class=w> </span><span class=n>f</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>JOIN</span><span class=w> </span><span class=n>hive</span><span class=p>.</span><span class=n>warehouse</span><span class=p>.</span><span class=n>dim_regions</span><span class=w> </span><span class=n>d</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>ON</span><span class=w> </span><span class=n>f</span><span class=p>.</span><span class=n>region_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>region_id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>Join ordering</strong> also matters. Filter early, join late. Push filters and aggregations as close to the base tables as possible so that intermediate result sets are small before they hit the join.</p><p><strong>Bad &ndash; join first, filter later:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>o</span><span class=p>.</span><span class=n>order_id</span><span class=p>,</span><span class=w> </span><span class=n>o</span><span class=p>.</span><span class=n>amount</span><span class=p>,</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>segment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=n>o</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>JOIN</span><span class=w> </span><span class=n>customers</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>o</span><span class=p>.</span><span class=n>customer_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>customer_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=n>o</span><span class=p>.</span><span class=n>dt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2026-02-01&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>segment</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;enterprise&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>Better &ndash; pre-filter with CTEs for clarity and to help the optimizer:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>WITH</span><span class=w> </span><span class=n>filtered_orders</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=n>order_id</span><span class=p>,</span><span class=w> </span><span class=n>amount</span><span class=p>,</span><span class=w> </span><span class=n>customer_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>orders</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>dt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2026-02-01&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>enterprise_customers</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=n>customer_id</span><span class=p>,</span><span class=w> </span><span class=n>segment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>customers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>segment</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;enterprise&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>o</span><span class=p>.</span><span class=n>order_id</span><span class=p>,</span><span class=w> </span><span class=n>o</span><span class=p>.</span><span class=n>amount</span><span class=p>,</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>segment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>filtered_orders</span><span class=w> </span><span class=n>o</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>JOIN</span><span class=w> </span><span class=n>enterprise_customers</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>o</span><span class=p>.</span><span class=n>customer_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>customer_id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>In practice, Trino&rsquo;s optimizer can often push predicates down through joins on its own. But making the intent explicit with CTEs both helps readability and gives the planner a clearer picture, especially in complex multi-join queries.</p><h2 id=3-data-type-and-format-considerations>3. Data Type and Format Considerations<a hidden class=anchor aria-hidden=true href=#3-data-type-and-format-considerations>#</a></h2><p>Your file format and schema design decisions are made long before query time, but they have a direct impact on performance.</p><ul><li><strong>Use columnar formats.</strong> Parquet and ORC both support column projection and predicate pushdown via min/max statistics. Avoid JSON and CSV for analytical tables.</li><li><strong>Select only the columns you need.</strong> With columnar formats, every column you add to your SELECT is an additional I/O cost.</li></ul><p><strong>Bad:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>hive</span><span class=p>.</span><span class=n>analytics</span><span class=p>.</span><span class=n>events</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=n>dt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2026-02-01&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>Optimized:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>user_id</span><span class=p>,</span><span class=w> </span><span class=n>event_type</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>hive</span><span class=p>.</span><span class=n>analytics</span><span class=p>.</span><span class=n>events</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=n>dt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2026-02-01&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>This is basic, but I still see <code>SELECT *</code> in production dashboards that read 200-column tables when only 4 columns are used. On a wide Parquet table the difference can be 10-20x in I/O.</p><p>Also watch your data types. Joining on a <code>VARCHAR</code> column when both sides could be <code>BIGINT</code> adds unnecessary overhead from hashing and comparison. If you control the pipeline, cast to the most efficient type upstream.</p><h2 id=4-query-profiling-with-explain-and-query-stats>4. Query Profiling with EXPLAIN and Query Stats<a hidden class=anchor aria-hidden=true href=#4-query-profiling-with-explain-and-query-stats>#</a></h2><p>Before optimizing blindly, measure. Trino gives you two essential tools:</p><p><strong>EXPLAIN</strong> shows the logical and distributed plan:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>user_id</span><span class=p>,</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>cnt</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>hive</span><span class=p>.</span><span class=n>analytics</span><span class=p>.</span><span class=n>events</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=n>dt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2026-02-01&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>user_id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Look for <code>ScanFilterProject</code> to verify predicate pushdown is happening. Check whether the join strategy is <code>REPLICATED</code> (broadcast) or <code>PARTITIONED</code> (distributed). If the plan shows a full <code>TableScan</code> with no filter, your predicates are not being pushed down.</p><p><strong>EXPLAIN ANALYZE</strong> actually runs the query and gives you runtime statistics:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>ANALYZE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>user_id</span><span class=p>,</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>cnt</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>hive</span><span class=p>.</span><span class=n>analytics</span><span class=p>.</span><span class=n>events</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=n>dt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2026-02-01&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>user_id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>This shows wall time, rows processed, data read per stage, and memory usage. I make it a habit to run <code>EXPLAIN ANALYZE</code> on any new query before it goes into a scheduled pipeline. The Trino Web UI also exposes per-query stats, stage-level timing, and memory breakdowns &ndash; all valuable for diagnosing bottlenecks.</p><h2 id=5-resource-management-tips>5. Resource Management Tips<a hidden class=anchor aria-hidden=true href=#5-resource-management-tips>#</a></h2><p>A single expensive query can starve an entire cluster. A few configuration and usage practices help:</p><ul><li><strong>Use resource groups</strong> to isolate workloads. Give ETL pipelines, ad-hoc analysts, and dashboards separate concurrency and memory limits so they do not interfere with each other.</li><li><strong>Limit concurrent queries</strong> per user or group. Even well-optimized queries add up when 50 of them run simultaneously.</li><li><strong>Set session-level memory limits</strong> for exploratory work:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>SESSION</span><span class=w> </span><span class=n>query_max_memory</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2GB&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>This prevents an accidental cross join from consuming the entire cluster&rsquo;s memory before it gets killed.</p><ul><li><strong>Avoid <code>ORDER BY</code> without <code>LIMIT</code></strong> on large result sets. Sorting requires materializing the full result in memory. If you just need the top N rows, always add <code>LIMIT</code>.</li></ul><h2 id=final-thoughts>Final Thoughts<a hidden class=anchor aria-hidden=true href=#final-thoughts>#</a></h2><p>Most Trino performance wins come from reading less data: prune partitions, select fewer columns, filter early. After that, getting join strategies right and profiling with <code>EXPLAIN ANALYZE</code> covers the majority of remaining issues. None of these tips are exotic &ndash; they are fundamentals that compound. Getting them right consistently is what separates a query that finishes in 3 seconds from one that times out.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://NhoSW.github.io/my-tech-blog/tags/trino/>Trino</a></li><li><a href=https://NhoSW.github.io/my-tech-blog/tags/sql/>Sql</a></li><li><a href=https://NhoSW.github.io/my-tech-blog/tags/optimization/>Optimization</a></li><li><a href=https://NhoSW.github.io/my-tech-blog/tags/performance/>Performance</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Trino Query Optimization: Practical Tips for Better Performance on x" href="https://x.com/intent/tweet/?text=Trino%20Query%20Optimization%3a%20Practical%20Tips%20for%20Better%20Performance&amp;url=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fposts%2ftrino-query-optimization-tips%2f&amp;hashtags=trino%2csql%2coptimization%2cperformance"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Trino Query Optimization: Practical Tips for Better Performance on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fposts%2ftrino-query-optimization-tips%2f&amp;title=Trino%20Query%20Optimization%3a%20Practical%20Tips%20for%20Better%20Performance&amp;summary=Trino%20Query%20Optimization%3a%20Practical%20Tips%20for%20Better%20Performance&amp;source=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fposts%2ftrino-query-optimization-tips%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Trino Query Optimization: Practical Tips for Better Performance on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fposts%2ftrino-query-optimization-tips%2f&title=Trino%20Query%20Optimization%3a%20Practical%20Tips%20for%20Better%20Performance"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Trino Query Optimization: Practical Tips for Better Performance on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fposts%2ftrino-query-optimization-tips%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Trino Query Optimization: Practical Tips for Better Performance on whatsapp" href="https://api.whatsapp.com/send?text=Trino%20Query%20Optimization%3a%20Practical%20Tips%20for%20Better%20Performance%20-%20https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fposts%2ftrino-query-optimization-tips%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Trino Query Optimization: Practical Tips for Better Performance on telegram" href="https://telegram.me/share/url?text=Trino%20Query%20Optimization%3a%20Practical%20Tips%20for%20Better%20Performance&amp;url=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fposts%2ftrino-query-optimization-tips%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Trino Query Optimization: Practical Tips for Better Performance on ycombinator" href="https://news.ycombinator.com/submitlink?t=Trino%20Query%20Optimization%3a%20Practical%20Tips%20for%20Better%20Performance&u=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fposts%2ftrino-query-optimization-tips%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://NhoSW.github.io/my-tech-blog/>OTL - Data Engineering</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>