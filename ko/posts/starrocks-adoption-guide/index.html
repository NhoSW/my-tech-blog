<!doctype html><html lang=ko dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기 | OTL - 데이터 엔지니어링</title><meta name=keywords content="starrocks,olap,real-time,kafka,performance-tuning,data-pipeline"><meta name=description content="기존 Trino + Airflow 파이프라인의 5분 지연을 서브초 레이턴시로 개선한 StarRocks 도입 과정을 정리했습니다. 테이블 모델 선택, 데이터 수집, 성능 튜닝, 운영 노하우까지 실무에서 얻은 교훈을 공유합니다."><meta name=author content="Seungwoo Noh"><link rel=canonical href=https://NhoSW.github.io/my-tech-blog/ko/posts/starrocks-adoption-guide/><link crossorigin=anonymous href=/my-tech-blog/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://NhoSW.github.io/my-tech-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://NhoSW.github.io/my-tech-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://NhoSW.github.io/my-tech-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://NhoSW.github.io/my-tech-blog/apple-touch-icon.png><link rel=mask-icon href=https://NhoSW.github.io/my-tech-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://NhoSW.github.io/my-tech-blog/ko/posts/starrocks-adoption-guide/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XXXXXXXXXX")}</script><meta property="og:url" content="https://NhoSW.github.io/my-tech-blog/ko/posts/starrocks-adoption-guide/"><meta property="og:site_name" content="OTL - 데이터 엔지니어링"><meta property="og:title" content="StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기"><meta property="og:description" content="기존 Trino + Airflow 파이프라인의 5분 지연을 서브초 레이턴시로 개선한 StarRocks 도입 과정을 정리했습니다. 테이블 모델 선택, 데이터 수집, 성능 튜닝, 운영 노하우까지 실무에서 얻은 교훈을 공유합니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-23T00:00:00+00:00"><meta property="article:modified_time" content="2026-02-23T00:00:00+00:00"><meta property="article:tag" content="Starrocks"><meta property="article:tag" content="Olap"><meta property="article:tag" content="Real-Time"><meta property="article:tag" content="Kafka"><meta property="article:tag" content="Performance-Tuning"><meta property="article:tag" content="Data-Pipeline"><meta name=twitter:card content="summary"><meta name=twitter:title content="StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기"><meta name=twitter:description content="기존 Trino + Airflow 파이프라인의 5분 지연을 서브초 레이턴시로 개선한 StarRocks 도입 과정을 정리했습니다. 테이블 모델 선택, 데이터 수집, 성능 튜닝, 운영 노하우까지 실무에서 얻은 교훈을 공유합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기","item":"https://NhoSW.github.io/my-tech-blog/ko/posts/starrocks-adoption-guide/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기","name":"StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기","description":"기존 Trino + Airflow 파이프라인의 5분 지연을 서브초 레이턴시로 개선한 StarRocks 도입 과정을 정리했습니다. 테이블 모델 선택, 데이터 수집, 성능 튜닝, 운영 노하우까지 실무에서 얻은 교훈을 공유합니다.","keywords":["starrocks","olap","real-time","kafka","performance-tuning","data-pipeline"],"articleBody":"도입 배경 데이터 파이프라인을 운영하다 보면 한 가지 고민에 반드시 부딪힌다. 실시간 대시보드를 어떻게 만들 것인가?\n우리 팀도 마찬가지였다. 기존 파이프라인은 다음과 같은 구조였다.\nService → Kafka → Iceberg → S3 → Trino → Airflow(5분) → Dashboard 겉보기엔 잘 동작했지만, 실무에서 체감하는 문제는 분명했다.\n최소 5분 지연: Airflow 스케줄 주기가 병목이었다 파이프라인 복잡도: Kafka → Flink → Redis → API → Dashboard로 이어지는 5개 이상의 컴포넌트 관리 반복되는 I/O: Trino가 매 쿼리마다 S3를 풀스캔하는 구조 높은 개발 비용: 새로운 실시간 대시보드 하나에 약 2주 소요 StarRocks를 도입한 후의 아키텍처는 이렇게 단순해졌다.\nService → Kafka → StarRocks → Dashboard (서브초 레이턴시) 중간 컴포넌트가 사라지면서 파이프라인이 극적으로 단순해졌고, 데이터가 Kafka에서 StarRocks로 직접 수집되면서 실시간성도 확보했다.\n도입 효과 약 3개월간의 PoC와 6개월간의 단계적 도입을 거쳐 다음과 같은 개선을 달성했다.\n항목 Before After 개선폭 대시보드 지연 5분 \u003c 1초 ~300배 대시보드 개발 기간 ~2주 ~1주 50% 단축 파이프라인 컴포넌트 5개 이상 2개 60% 감소 쿼리 응답 시간 30~50초 5~10초 5~10배 하드웨어 비용 128GB × 18노드 64GB × 3노드 ~75% 절감 Trino는 절대적인 쿼리 시간에서는 빠르지만, Airflow 스케줄 지연을 포함한 end-to-end 레이턴시와 하드웨어 비용 효율 면에서 StarRocks가 실시간 워크로드에 더 적합했다.\n테이블 모델 선택 가이드 StarRocks를 처음 도입할 때 가장 중요한 결정이 테이블 모델 선택이다. 잘못 고르면 나중에 테이블을 다시 만들어야 한다.\n의사결정 흐름 ┌─────────────────────────────┐ │ 어떤 데이터를 저장하는가? │ └──────────────┬──────────────┘ │ ┌───────▼────────┐ │ UPDATE 필요? │ └───────┬────────┘ │ ┌────────┴────────┐ │ │ [아니오] [예] │ │ ┌─────▼─────┐ ┌─────▼──────┐ │ 집계 필요? │ │ Primary Key │ └─────┬─────┘ │ (빈번한 │ │ │ UPDATE) │ [아니오] [예] └────────────┘ │ │ ┌─────▼───┐ ┌▼──────────┐ │Duplicate│ │Aggregate │ │(원본 저장)│ │(자동 집계) ★│ └─────────┘ └────────────┘ 모델 비교 모델 중복 허용 UPDATE 자동 집계 적합한 용도 Duplicate Key O X X 로그, 원본 이벤트 Aggregate Key X 자동 O 실시간 통계 ★ Primary Key X O (고속) X 빈번한 UPDATE Duplicate Key: 원본 데이터 저장 클릭 로그, API 이벤트, 센서 데이터처럼 원본을 그대로 보관해야 할 때 사용한다.\nCREATE TABLE order_events ( event_id BIGINT, event_time DATETIME, order_id VARCHAR(50), user_id BIGINT, event_type VARCHAR(20), amount DECIMAL(10, 2) ) DUPLICATE KEY(event_id, event_time) PARTITION BY date_trunc('day', event_time) DISTRIBUTED BY HASH(event_id) BUCKETS 10; Aggregate Key: 실시간 통계 ★ 데이터가 수집되는 시점에 자동으로 집계가 일어난다. 이 모델이 StarRocks 도입의 핵심이었다.\nCREATE TABLE order_stats ( stat_time DATETIME NOT NULL COMMENT '5분 간격', region VARCHAR(20) NOT NULL, delivery_type VARCHAR(20) NOT NULL, -- 집계 컬럼: 수집 시 자동으로 집계 함수 적용 order_count BIGINT SUM DEFAULT \"0\", total_amount DECIMAL(15, 2) SUM DEFAULT \"0\", user_bitmap BITMAP BITMAP_UNION, max_amount DECIMAL(10, 2) MAX ) AGGREGATE KEY(stat_time, region, delivery_type) PARTITION BY date_trunc('day', stat_time) DISTRIBUTED BY HASH(stat_time) BUCKETS 10; 사용 가능한 집계 함수:\n함수 용도 예시 SUM 합계 주문 건수, 매출 합계 MAX / MIN 최대/최소값 최고가, 최저가 REPLACE 최신 값 덮어쓰기 최종 상태 BITMAP_UNION 정확한 유니크 카운트 순 이용자 수 HLL_UNION 근사 유니크 카운트 대규모 카디널리티 BITMAP_UNION은 HyperLogLog와 달리 정확한 유니크 카운트를 제공한다. 비즈니스 KPI 대시보드처럼 정확도가 중요한 경우 반드시 이 방식을 사용하자.\nPrimary Key: 빈번한 UPDATE 주문 상태 추적, 재고 관리처럼 같은 키의 데이터가 자주 갱신되는 경우에 적합하다.\nCREATE TABLE orders ( order_id VARCHAR(50) NOT NULL, status VARCHAR(20), amount DECIMAL(10, 2), updated_at DATETIME ) PRIMARY KEY(order_id) DISTRIBUTED BY HASH(order_id) BUCKETS 10 PROPERTIES ( \"enable_persistent_index\" = \"true\" ); enable_persistent_index를 활성화하면 UPDATE 성능이 크게 향상된다.\n데이터 수집 Routine Load: Kafka 실시간 연동 Kafka 토픽에서 데이터를 연속으로 수집하는 방식이다. 대부분의 실시간 파이프라인에서 이 방식을 사용한다.\nCREATE ROUTINE LOAD order_load ON orders COLUMNS( order_id, user_id, timestamp_ms, amount, order_date = FROM_UNIXTIME(timestamp_ms / 1000) ) PROPERTIES ( \"format\" = \"json\", \"jsonpaths\" = \"[\\\"$.orderId\\\",\\\"$.userId\\\",\\\"$.timestamp\\\",\\\"$.amount\\\"]\" ) FROM KAFKA ( \"kafka_broker_list\" = \"kafka-broker:9092\", \"kafka_topic\" = \"orders\" ); Aggregate Key 테이블과 결합하면 수집 시점에 변환과 집계를 동시에 처리할 수 있다.\nCREATE ROUTINE LOAD order_stats_load ON order_stats COLUMNS( timestamp_ms, region, amount, user_id, -- 5분 간격으로 라운딩 stat_time = FROM_UNIXTIME(FLOOR(timestamp_ms / 1000 / 300) * 300), order_count = 1, total_amount = amount, user_bitmap = BITMAP_HASH(user_id) ) WHERE amount \u003e 0 PROPERTIES (\"format\" = \"json\") FROM KAFKA ( \"kafka_broker_list\" = \"kafka-broker:9092\", \"kafka_topic\" = \"orders\" ); 이 패턴 하나로 기존에 Flink로 처리하던 집계 로직을 SQL만으로 대체할 수 있었다.\nStream Load: 벌크 데이터 로딩 파일이나 API를 통한 일회성 대량 로딩에 적합하다.\n# CSV 파일 로딩 curl --location-trusted \\ -u user:password \\ -H \"label:load_$(date +%Y%m%d%H%M%S)\" \\ -H \"column_separator:,\" \\ -T data.csv \\ http://starrocks-fe:8030/api/mydb/mytable/_stream_load 성능 튜닝 실전 팁 Thread Pool 설정 동시 접속이 500 RPS 이상인 고부하 환경에서는 기본 Thread Pool 크기가 부족하다.\n# be.conf pipeline_scan_thread_pool_thread_num = 32 # 기본값: 24 pipeline_exec_thread_pool_thread_num = 32 # 기본값: 24 Bucket Count 가이드라인 데이터 크기 권장 Bucket 수 \u003c 10 GB 10 10~50 GB 20 50~100 GB 30 \u003e 100 GB 50+ 산정 공식: buckets = max(1, 데이터_크기_GB / 10)\n파티셔닝 전략 파티션 컬럼에 함수를 사용하면 파티션 프루닝이 동작하지 않는다. 이것은 생각보다 자주 실수하는 부분이다.\n-- ✅ 올바른 사용: 파티션 프루닝 동작 WHERE event_time \u003e= NOW() - INTERVAL 3 DAY -- ❌ 잘못된 사용: 파티션 프루닝 불가 WHERE DATE(event_time) \u003e= CURRENT_DATE - 3 TTL 설정 오래된 파티션을 자동으로 삭제하려면 TTL을 설정한다.\nPROPERTIES ( \"partition_live_number\" = \"3\" -- 최근 3개 파티션만 유지 ) 운영 노하우 Materialized View 관리 ASYNC 리프레시가 예고 없이 멈추는 경우가 있다. 정기적으로 상태를 확인하고, 문제 발생 시 수동으로 복구해야 한다.\n-- 상태 확인 SHOW MATERIALIZED VIEWS; -- 강제 동기 리프레시 REFRESH MATERIALIZED VIEW db.mv_name WITH SYNC MODE; -- 비활성화된 MV 재활성화 ALTER MATERIALIZED VIEW db.mv_name ACTIVE; Routine Load 모니터링 상태가 PAUSED로 전환되는 경우가 잦다. Kafka offset 문제나 비정상 메시지가 원인이다.\n-- 상태 확인 SHOW ROUTINE LOAD FOR db.load_job; -- 재개 RESUME ROUTINE LOAD FOR db.load_job; Scale-in 주의사항 노드를 축소할 때는 반드시 Decommission을 먼저 수행해야 한다. 이 절차 없이 노드를 줄이면 데이터가 유실된다.\n-- 1. 현재 노드 확인 SHOW PROC '/backends'; -- 2. 디커미션 시작 ALTER SYSTEM DECOMMISSION BACKEND \":\"; -- 3. TabletNum이 0이 될 때까지 대기 후 제거 ALTER SYSTEM DROP BACKEND \":\"; 도입 시 알아두면 좋은 것들 알려진 제약 사항 이슈 설명 대안 Routine Load 비정상 메시지 처리 한계 Kafka 단에서 사전 검증 datetime 파티션 Iceberg datetime 파티션 호환 이슈 대체 파티션 전략 사용 버전 업그레이드 4.x 대에서 버그 경험 스테이징 환경 필수 테스트 버전 업그레이드는 반드시 스테이징 환경에서 충분히 검증한 뒤 프로덕션에 적용하자. 실제로 여러 차례 업그레이드/다운그레이드를 반복한 경험이 있다. 롤백 계획은 항상 준비해두어야 한다.\n도입 체크리스트 배포 전\n유스케이스와 요구사항 정의 데이터 볼륨 및 증가량 추정 테이블 모델 선택 파티션 전략 설계 배포 후\nRoutine Load 작업 생성 및 검증 사용자 권한 설정 데이터 보관 정책(TTL) 설정 Scale-in/out 절차 문서화 모니터링 대시보드 구성 마치며 StarRocks 도입에서 얻은 핵심 교훈을 정리하면 다음과 같다.\nAggregate Key 모델이 핵심이다 — 수집 시점 자동 집계로 스토리지와 쿼리 성능을 동시에 잡을 수 있다 BITMAP_UNION으로 정확한 유니크 카운트를 확보하자 — 비즈니스 KPI에는 근사치가 아닌 정확한 수치가 필요하다 Routine Load + Aggregate Key 조합이 Flink를 대체한다 — SQL만으로 실시간 집계 파이프라인을 구축할 수 있다 운영 자동화에 투자하자 — Materialized View와 Routine Load 모니터링은 필수다 실시간 분석 워크로드에서 StarRocks는 파이프라인 복잡도를 획기적으로 줄여주는 강력한 선택지다. 다만 버전 업그레이드와 운영 안정성 측면에서는 아직 성숙해지는 과정에 있으므로, 충분한 PoC와 스테이징 검증을 거쳐 도입하길 권장한다.\n참고 자료: StarRocks 공식 문서\n","wordCount":"1141","inLanguage":"ko","datePublished":"2026-02-23T00:00:00Z","dateModified":"2026-02-23T00:00:00Z","author":{"@type":"Person","name":"Seungwoo Noh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://NhoSW.github.io/my-tech-blog/ko/posts/starrocks-adoption-guide/"},"publisher":{"@type":"Organization","name":"OTL - 데이터 엔지니어링","logo":{"@type":"ImageObject","url":"https://NhoSW.github.io/my-tech-blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://NhoSW.github.io/my-tech-blog/ko/ accesskey=h title="OTL - 데이터 엔지니어링 (Alt + H)">OTL - 데이터 엔지니어링</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://NhoSW.github.io/my-tech-blog/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://NhoSW.github.io/ko/my-tech-blog/ko/ title=홈><span>홈</span></a></li><li><a href=https://NhoSW.github.io/ko/my-tech-blog/ko/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://NhoSW.github.io/ko/my-tech-blog/ko/tags/ title=태그><span>태그</span></a></li><li><a href=https://NhoSW.github.io/ko/my-tech-blog/ko/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://NhoSW.github.io/ko/my-tech-blog/ko/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li><li><a href=https://NhoSW.github.io/ko/my-tech-blog/ko/about/ title=소개><span>소개</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://NhoSW.github.io/my-tech-blog/ko/>홈</a></div><h1 class="post-title entry-hint-parent">StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기</h1><div class=post-meta><span title='2026-02-23 00:00:00 +0000 UTC'>2026년 2월 23일</span>&nbsp;·&nbsp;<span>6 분</span>&nbsp;·&nbsp;<span>Seungwoo Noh</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/NhoSW/my-tech-blog/tree/main/content/posts/starrocks-adoption-guide.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%eb%8f%84%ec%9e%85-%eb%b0%b0%ea%b2%bd aria-label="도입 배경">도입 배경</a></li><li><a href=#%eb%8f%84%ec%9e%85-%ed%9a%a8%ea%b3%bc aria-label="도입 효과">도입 효과</a></li><li><a href=#%ed%85%8c%ec%9d%b4%eb%b8%94-%eb%aa%a8%eb%8d%b8-%ec%84%a0%ed%83%9d-%ea%b0%80%ec%9d%b4%eb%93%9c aria-label="테이블 모델 선택 가이드">테이블 모델 선택 가이드</a><ul><li><a href=#%ec%9d%98%ec%82%ac%ea%b2%b0%ec%a0%95-%ed%9d%90%eb%a6%84 aria-label="의사결정 흐름">의사결정 흐름</a></li><li><a href=#%eb%aa%a8%eb%8d%b8-%eb%b9%84%ea%b5%90 aria-label="모델 비교">모델 비교</a></li><li><a href=#duplicate-key-%ec%9b%90%eb%b3%b8-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%a0%80%ec%9e%a5 aria-label="Duplicate Key: 원본 데이터 저장">Duplicate Key: 원본 데이터 저장</a></li><li><a href=#aggregate-key-%ec%8b%a4%ec%8b%9c%ea%b0%84-%ed%86%b5%ea%b3%84- aria-label="Aggregate Key: 실시간 통계 ★">Aggregate Key: 실시간 통계 ★</a></li><li><a href=#primary-key-%eb%b9%88%eb%b2%88%ed%95%9c-update aria-label="Primary Key: 빈번한 UPDATE">Primary Key: 빈번한 UPDATE</a></li></ul></li><li><a href=#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%88%98%ec%a7%91 aria-label="데이터 수집">데이터 수집</a><ul><li><a href=#routine-load-kafka-%ec%8b%a4%ec%8b%9c%ea%b0%84-%ec%97%b0%eb%8f%99 aria-label="Routine Load: Kafka 실시간 연동">Routine Load: Kafka 실시간 연동</a></li><li><a href=#stream-load-%eb%b2%8c%ed%81%ac-%eb%8d%b0%ec%9d%b4%ed%84%b0-%eb%a1%9c%eb%94%a9 aria-label="Stream Load: 벌크 데이터 로딩">Stream Load: 벌크 데이터 로딩</a></li></ul></li><li><a href=#%ec%84%b1%eb%8a%a5-%ed%8a%9c%eb%8b%9d-%ec%8b%a4%ec%a0%84-%ed%8c%81 aria-label="성능 튜닝 실전 팁">성능 튜닝 실전 팁</a><ul><li><a href=#thread-pool-%ec%84%a4%ec%a0%95 aria-label="Thread Pool 설정">Thread Pool 설정</a></li><li><a href=#bucket-count-%ea%b0%80%ec%9d%b4%eb%93%9c%eb%9d%bc%ec%9d%b8 aria-label="Bucket Count 가이드라인">Bucket Count 가이드라인</a></li><li><a href=#%ed%8c%8c%ed%8b%b0%ec%85%94%eb%8b%9d-%ec%a0%84%eb%9e%b5 aria-label="파티셔닝 전략">파티셔닝 전략</a></li><li><a href=#ttl-%ec%84%a4%ec%a0%95 aria-label="TTL 설정">TTL 설정</a></li></ul></li><li><a href=#%ec%9a%b4%ec%98%81-%eb%85%b8%ed%95%98%ec%9a%b0 aria-label="운영 노하우">운영 노하우</a><ul><li><a href=#materialized-view-%ea%b4%80%eb%a6%ac aria-label="Materialized View 관리">Materialized View 관리</a></li><li><a href=#routine-load-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81 aria-label="Routine Load 모니터링">Routine Load 모니터링</a></li><li><a href=#scale-in-%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad aria-label="Scale-in 주의사항">Scale-in 주의사항</a></li></ul></li><li><a href=#%eb%8f%84%ec%9e%85-%ec%8b%9c-%ec%95%8c%ec%95%84%eb%91%90%eb%a9%b4-%ec%a2%8b%ec%9d%80-%ea%b2%83%eb%93%a4 aria-label="도입 시 알아두면 좋은 것들">도입 시 알아두면 좋은 것들</a><ul><li><a href=#%ec%95%8c%eb%a0%a4%ec%a7%84-%ec%a0%9c%ec%95%bd-%ec%82%ac%ed%95%ad aria-label="알려진 제약 사항">알려진 제약 사항</a></li><li><a href=#%eb%8f%84%ec%9e%85-%ec%b2%b4%ed%81%ac%eb%a6%ac%ec%8a%a4%ed%8a%b8 aria-label="도입 체크리스트">도입 체크리스트</a></li></ul></li><li><a href=#%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label=마치며>마치며</a></li></ul></div></details></div><div class=post-content><h2 id=도입-배경>도입 배경<a hidden class=anchor aria-hidden=true href=#도입-배경>#</a></h2><p>데이터 파이프라인을 운영하다 보면 한 가지 고민에 반드시 부딪힌다. <strong>실시간 대시보드를 어떻게 만들 것인가?</strong></p><p>우리 팀도 마찬가지였다. 기존 파이프라인은 다음과 같은 구조였다.</p><pre tabindex=0><code>Service → Kafka → Iceberg → S3 → Trino → Airflow(5분) → Dashboard
</code></pre><p>겉보기엔 잘 동작했지만, 실무에서 체감하는 문제는 분명했다.</p><ul><li><strong>최소 5분 지연</strong>: Airflow 스케줄 주기가 병목이었다</li><li><strong>파이프라인 복잡도</strong>: Kafka → Flink → Redis → API → Dashboard로 이어지는 5개 이상의 컴포넌트 관리</li><li><strong>반복되는 I/O</strong>: Trino가 매 쿼리마다 S3를 풀스캔하는 구조</li><li><strong>높은 개발 비용</strong>: 새로운 실시간 대시보드 하나에 약 2주 소요</li></ul><p>StarRocks를 도입한 후의 아키텍처는 이렇게 단순해졌다.</p><pre tabindex=0><code>Service → Kafka → StarRocks → Dashboard (서브초 레이턴시)
</code></pre><p>중간 컴포넌트가 사라지면서 파이프라인이 극적으로 단순해졌고, 데이터가 Kafka에서 StarRocks로 직접 수집되면서 실시간성도 확보했다.</p><h2 id=도입-효과>도입 효과<a hidden class=anchor aria-hidden=true href=#도입-효과>#</a></h2><p>약 3개월간의 PoC와 6개월간의 단계적 도입을 거쳐 다음과 같은 개선을 달성했다.</p><table><thead><tr><th>항목</th><th>Before</th><th>After</th><th>개선폭</th></tr></thead><tbody><tr><td>대시보드 지연</td><td>5분</td><td>&lt; 1초</td><td>~300배</td></tr><tr><td>대시보드 개발 기간</td><td>~2주</td><td>~1주</td><td>50% 단축</td></tr><tr><td>파이프라인 컴포넌트</td><td>5개 이상</td><td>2개</td><td>60% 감소</td></tr><tr><td>쿼리 응답 시간</td><td>30~50초</td><td>5~10초</td><td>5~10배</td></tr><tr><td>하드웨어 비용</td><td>128GB × 18노드</td><td>64GB × 3노드</td><td>~75% 절감</td></tr></tbody></table><blockquote><p>Trino는 절대적인 쿼리 시간에서는 빠르지만, Airflow 스케줄 지연을 포함한 <strong>end-to-end 레이턴시</strong>와 하드웨어 비용 효율 면에서 StarRocks가 실시간 워크로드에 더 적합했다.</p></blockquote><h2 id=테이블-모델-선택-가이드>테이블 모델 선택 가이드<a hidden class=anchor aria-hidden=true href=#테이블-모델-선택-가이드>#</a></h2><p>StarRocks를 처음 도입할 때 가장 중요한 결정이 테이블 모델 선택이다. 잘못 고르면 나중에 테이블을 다시 만들어야 한다.</p><h3 id=의사결정-흐름>의사결정 흐름<a hidden class=anchor aria-hidden=true href=#의사결정-흐름>#</a></h3><pre tabindex=0><code>┌─────────────────────────────┐
│  어떤 데이터를 저장하는가?    │
└──────────────┬──────────────┘
               │
       ┌───────▼────────┐
       │  UPDATE 필요?   │
       └───────┬────────┘
               │
      ┌────────┴────────┐
      │                 │
    [아니오]            [예]
      │                 │
┌─────▼─────┐    ┌─────▼──────┐
│  집계 필요? │    │ Primary Key │
└─────┬─────┘    │ (빈번한     │
      │          │  UPDATE)    │
  [아니오]  [예]  └────────────┘
      │      │
┌─────▼───┐ ┌▼──────────┐
│Duplicate│ │Aggregate   │
│(원본 저장)│ │(자동 집계) ★│
└─────────┘ └────────────┘
</code></pre><h3 id=모델-비교>모델 비교<a hidden class=anchor aria-hidden=true href=#모델-비교>#</a></h3><table><thead><tr><th>모델</th><th>중복 허용</th><th>UPDATE</th><th>자동 집계</th><th>적합한 용도</th></tr></thead><tbody><tr><td>Duplicate Key</td><td>O</td><td>X</td><td>X</td><td>로그, 원본 이벤트</td></tr><tr><td>Aggregate Key</td><td>X</td><td>자동</td><td>O</td><td>실시간 통계 ★</td></tr><tr><td>Primary Key</td><td>X</td><td>O (고속)</td><td>X</td><td>빈번한 UPDATE</td></tr></tbody></table><h3 id=duplicate-key-원본-데이터-저장>Duplicate Key: 원본 데이터 저장<a hidden class=anchor aria-hidden=true href=#duplicate-key-원본-데이터-저장>#</a></h3><p>클릭 로그, API 이벤트, 센서 데이터처럼 원본을 그대로 보관해야 할 때 사용한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>order_events</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>event_id</span><span class=w> </span><span class=nb>BIGINT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>event_time</span><span class=w> </span><span class=n>DATETIME</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>order_id</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>user_id</span><span class=w> </span><span class=nb>BIGINT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>event_type</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>amount</span><span class=w> </span><span class=nb>DECIMAL</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>DUPLICATE</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=n>event_id</span><span class=p>,</span><span class=w> </span><span class=n>event_time</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>date_trunc</span><span class=p>(</span><span class=s1>&#39;day&#39;</span><span class=p>,</span><span class=w> </span><span class=n>event_time</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>DISTRIBUTED</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>HASH</span><span class=p>(</span><span class=n>event_id</span><span class=p>)</span><span class=w> </span><span class=n>BUCKETS</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=aggregate-key-실시간-통계->Aggregate Key: 실시간 통계 ★<a hidden class=anchor aria-hidden=true href=#aggregate-key-실시간-통계->#</a></h3><p>데이터가 수집되는 시점에 <strong>자동으로 집계</strong>가 일어난다. 이 모델이 StarRocks 도입의 핵심이었다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>order_stats</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>stat_time</span><span class=w> </span><span class=n>DATETIME</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;5분 간격&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>region</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>delivery_type</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- 집계 컬럼: 수집 시 자동으로 집계 함수 적용
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>order_count</span><span class=w> </span><span class=nb>BIGINT</span><span class=w> </span><span class=k>SUM</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=s2>&#34;0&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>total_amount</span><span class=w> </span><span class=nb>DECIMAL</span><span class=p>(</span><span class=mi>15</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=k>SUM</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=s2>&#34;0&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>user_bitmap</span><span class=w> </span><span class=n>BITMAP</span><span class=w> </span><span class=n>BITMAP_UNION</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>max_amount</span><span class=w> </span><span class=nb>DECIMAL</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=k>MAX</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>AGGREGATE</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=n>stat_time</span><span class=p>,</span><span class=w> </span><span class=n>region</span><span class=p>,</span><span class=w> </span><span class=n>delivery_type</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>date_trunc</span><span class=p>(</span><span class=s1>&#39;day&#39;</span><span class=p>,</span><span class=w> </span><span class=n>stat_time</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>DISTRIBUTED</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>HASH</span><span class=p>(</span><span class=n>stat_time</span><span class=p>)</span><span class=w> </span><span class=n>BUCKETS</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>사용 가능한 집계 함수:</p><table><thead><tr><th>함수</th><th>용도</th><th>예시</th></tr></thead><tbody><tr><td><code>SUM</code></td><td>합계</td><td>주문 건수, 매출 합계</td></tr><tr><td><code>MAX</code> / <code>MIN</code></td><td>최대/최소값</td><td>최고가, 최저가</td></tr><tr><td><code>REPLACE</code></td><td>최신 값 덮어쓰기</td><td>최종 상태</td></tr><tr><td><code>BITMAP_UNION</code></td><td>정확한 유니크 카운트</td><td>순 이용자 수</td></tr><tr><td><code>HLL_UNION</code></td><td>근사 유니크 카운트</td><td>대규모 카디널리티</td></tr></tbody></table><blockquote><p><code>BITMAP_UNION</code>은 HyperLogLog와 달리 <strong>정확한</strong> 유니크 카운트를 제공한다. 비즈니스 KPI 대시보드처럼 정확도가 중요한 경우 반드시 이 방식을 사용하자.</p></blockquote><h3 id=primary-key-빈번한-update>Primary Key: 빈번한 UPDATE<a hidden class=anchor aria-hidden=true href=#primary-key-빈번한-update>#</a></h3><p>주문 상태 추적, 재고 관리처럼 같은 키의 데이터가 자주 갱신되는 경우에 적합하다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>order_id</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>status</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>amount</span><span class=w> </span><span class=nb>DECIMAL</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>updated_at</span><span class=w> </span><span class=n>DATETIME</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=n>order_id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>DISTRIBUTED</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>HASH</span><span class=p>(</span><span class=n>order_id</span><span class=p>)</span><span class=w> </span><span class=n>BUCKETS</span><span class=w> </span><span class=mi>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>PROPERTIES</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;enable_persistent_index&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;true&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><blockquote><p><code>enable_persistent_index</code>를 활성화하면 UPDATE 성능이 크게 향상된다.</p></blockquote><h2 id=데이터-수집>데이터 수집<a hidden class=anchor aria-hidden=true href=#데이터-수집>#</a></h2><h3 id=routine-load-kafka-실시간-연동>Routine Load: Kafka 실시간 연동<a hidden class=anchor aria-hidden=true href=#routine-load-kafka-실시간-연동>#</a></h3><p>Kafka 토픽에서 데이터를 연속으로 수집하는 방식이다. 대부분의 실시간 파이프라인에서 이 방식을 사용한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>ROUTINE</span><span class=w> </span><span class=k>LOAD</span><span class=w> </span><span class=n>order_load</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>orders</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>COLUMNS</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>order_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>user_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>timestamp_ms</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>amount</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>order_date</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>FROM_UNIXTIME</span><span class=p>(</span><span class=n>timestamp_ms</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>1000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>PROPERTIES</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;format&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;json&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;jsonpaths&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;[\&#34;</span><span class=err>$</span><span class=p>.</span><span class=n>orderId</span><span class=err>\</span><span class=s2>&#34;,\&#34;</span><span class=err>$</span><span class=p>.</span><span class=n>userId</span><span class=err>\</span><span class=s2>&#34;,\&#34;</span><span class=err>$</span><span class=p>.</span><span class=k>timestamp</span><span class=err>\</span><span class=s2>&#34;,\&#34;</span><span class=err>$</span><span class=p>.</span><span class=n>amount</span><span class=err>\</span><span class=s2>&#34;]&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>KAFKA</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;kafka_broker_list&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;kafka-broker:9092&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;kafka_topic&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;orders&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Aggregate Key 테이블과 결합하면 <strong>수집 시점에 변환과 집계를 동시에</strong> 처리할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>ROUTINE</span><span class=w> </span><span class=k>LOAD</span><span class=w> </span><span class=n>order_stats_load</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>order_stats</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>COLUMNS</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>timestamp_ms</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>region</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>amount</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>user_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- 5분 간격으로 라운딩
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>stat_time</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>FROM_UNIXTIME</span><span class=p>(</span><span class=n>FLOOR</span><span class=p>(</span><span class=n>timestamp_ms</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>1000</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>300</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>300</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>order_count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>total_amount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>amount</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>user_bitmap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BITMAP_HASH</span><span class=p>(</span><span class=n>user_id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=n>amount</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>PROPERTIES</span><span class=w> </span><span class=p>(</span><span class=s2>&#34;format&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;json&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>KAFKA</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;kafka_broker_list&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;kafka-broker:9092&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;kafka_topic&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;orders&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>이 패턴 하나로 기존에 Flink로 처리하던 집계 로직을 SQL만으로 대체할 수 있었다.</p><h3 id=stream-load-벌크-데이터-로딩>Stream Load: 벌크 데이터 로딩<a hidden class=anchor aria-hidden=true href=#stream-load-벌크-데이터-로딩>#</a></h3><p>파일이나 API를 통한 일회성 대량 로딩에 적합하다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># CSV 파일 로딩</span>
</span></span><span class=line><span class=cl>curl --location-trusted <span class=se>\
</span></span></span><span class=line><span class=cl>  -u user:password <span class=se>\
</span></span></span><span class=line><span class=cl>  -H <span class=s2>&#34;label:load_</span><span class=k>$(</span>date +%Y%m%d%H%M%S<span class=k>)</span><span class=s2>&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl>  -H <span class=s2>&#34;column_separator:,&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl>  -T data.csv <span class=se>\
</span></span></span><span class=line><span class=cl>  http://starrocks-fe:8030/api/mydb/mytable/_stream_load
</span></span></code></pre></div><h2 id=성능-튜닝-실전-팁>성능 튜닝 실전 팁<a hidden class=anchor aria-hidden=true href=#성능-튜닝-실전-팁>#</a></h2><h3 id=thread-pool-설정>Thread Pool 설정<a hidden class=anchor aria-hidden=true href=#thread-pool-설정>#</a></h3><p>동시 접속이 500 RPS 이상인 고부하 환경에서는 기본 Thread Pool 크기가 부족하다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=c1># be.conf</span>
</span></span><span class=line><span class=cl><span class=na>pipeline_scan_thread_pool_thread_num</span> <span class=o>=</span> <span class=s>32   # 기본값: 24</span>
</span></span><span class=line><span class=cl><span class=na>pipeline_exec_thread_pool_thread_num</span> <span class=o>=</span> <span class=s>32   # 기본값: 24</span>
</span></span></code></pre></div><h3 id=bucket-count-가이드라인>Bucket Count 가이드라인<a hidden class=anchor aria-hidden=true href=#bucket-count-가이드라인>#</a></h3><table><thead><tr><th>데이터 크기</th><th>권장 Bucket 수</th></tr></thead><tbody><tr><td>&lt; 10 GB</td><td>10</td></tr><tr><td>10~50 GB</td><td>20</td></tr><tr><td>50~100 GB</td><td>30</td></tr><tr><td>> 100 GB</td><td>50+</td></tr></tbody></table><p>산정 공식: <code>buckets = max(1, 데이터_크기_GB / 10)</code></p><h3 id=파티셔닝-전략>파티셔닝 전략<a hidden class=anchor aria-hidden=true href=#파티셔닝-전략>#</a></h3><p>파티션 컬럼에 함수를 사용하면 파티션 프루닝이 동작하지 않는다. 이것은 생각보다 자주 실수하는 부분이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- ✅ 올바른 사용: 파티션 프루닝 동작
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=n>event_time</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>NOW</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=nb>INTERVAL</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=k>DAY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- ❌ 잘못된 사용: 파티션 프루닝 불가
</span></span></span><span class=line><span class=cl><span class=k>WHERE</span><span class=w> </span><span class=nb>DATE</span><span class=p>(</span><span class=n>event_time</span><span class=p>)</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=k>CURRENT_DATE</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>3</span><span class=w>
</span></span></span></code></pre></div><h3 id=ttl-설정>TTL 설정<a hidden class=anchor aria-hidden=true href=#ttl-설정>#</a></h3><p>오래된 파티션을 자동으로 삭제하려면 TTL을 설정한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>PROPERTIES</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;partition_live_number&#34;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;3&#34;</span><span class=w>  </span><span class=c1>-- 최근 3개 파티션만 유지
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h2 id=운영-노하우>운영 노하우<a hidden class=anchor aria-hidden=true href=#운영-노하우>#</a></h2><h3 id=materialized-view-관리>Materialized View 관리<a hidden class=anchor aria-hidden=true href=#materialized-view-관리>#</a></h3><p>ASYNC 리프레시가 예고 없이 멈추는 경우가 있다. 정기적으로 상태를 확인하고, 문제 발생 시 수동으로 복구해야 한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 상태 확인
</span></span></span><span class=line><span class=cl><span class=k>SHOW</span><span class=w> </span><span class=n>MATERIALIZED</span><span class=w> </span><span class=n>VIEWS</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 강제 동기 리프레시
</span></span></span><span class=line><span class=cl><span class=n>REFRESH</span><span class=w> </span><span class=n>MATERIALIZED</span><span class=w> </span><span class=k>VIEW</span><span class=w> </span><span class=n>db</span><span class=p>.</span><span class=n>mv_name</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=n>SYNC</span><span class=w> </span><span class=k>MODE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 비활성화된 MV 재활성화
</span></span></span><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=n>MATERIALIZED</span><span class=w> </span><span class=k>VIEW</span><span class=w> </span><span class=n>db</span><span class=p>.</span><span class=n>mv_name</span><span class=w> </span><span class=n>ACTIVE</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=routine-load-모니터링>Routine Load 모니터링<a hidden class=anchor aria-hidden=true href=#routine-load-모니터링>#</a></h3><p>상태가 <code>PAUSED</code>로 전환되는 경우가 잦다. Kafka offset 문제나 비정상 메시지가 원인이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 상태 확인
</span></span></span><span class=line><span class=cl><span class=k>SHOW</span><span class=w> </span><span class=k>ROUTINE</span><span class=w> </span><span class=k>LOAD</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=n>db</span><span class=p>.</span><span class=n>load_job</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 재개
</span></span></span><span class=line><span class=cl><span class=n>RESUME</span><span class=w> </span><span class=k>ROUTINE</span><span class=w> </span><span class=k>LOAD</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=n>db</span><span class=p>.</span><span class=n>load_job</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=scale-in-주의사항>Scale-in 주의사항<a hidden class=anchor aria-hidden=true href=#scale-in-주의사항>#</a></h3><p>노드를 축소할 때는 <strong>반드시 Decommission을 먼저</strong> 수행해야 한다. 이 절차 없이 노드를 줄이면 데이터가 유실된다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 1. 현재 노드 확인
</span></span></span><span class=line><span class=cl><span class=k>SHOW</span><span class=w> </span><span class=n>PROC</span><span class=w> </span><span class=s1>&#39;/backends&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 2. 디커미션 시작
</span></span></span><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>SYSTEM</span><span class=w> </span><span class=n>DECOMMISSION</span><span class=w> </span><span class=n>BACKEND</span><span class=w> </span><span class=s2>&#34;&lt;BE_IP&gt;:&lt;HEARTBEAT_PORT&gt;&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 3. TabletNum이 0이 될 때까지 대기 후 제거
</span></span></span><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>SYSTEM</span><span class=w> </span><span class=k>DROP</span><span class=w> </span><span class=n>BACKEND</span><span class=w> </span><span class=s2>&#34;&lt;BE_IP&gt;:&lt;HEARTBEAT_PORT&gt;&#34;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h2 id=도입-시-알아두면-좋은-것들>도입 시 알아두면 좋은 것들<a hidden class=anchor aria-hidden=true href=#도입-시-알아두면-좋은-것들>#</a></h2><h3 id=알려진-제약-사항>알려진 제약 사항<a hidden class=anchor aria-hidden=true href=#알려진-제약-사항>#</a></h3><table><thead><tr><th>이슈</th><th>설명</th><th>대안</th></tr></thead><tbody><tr><td>Routine Load</td><td>비정상 메시지 처리 한계</td><td>Kafka 단에서 사전 검증</td></tr><tr><td>datetime 파티션</td><td>Iceberg datetime 파티션 호환 이슈</td><td>대체 파티션 전략 사용</td></tr><tr><td>버전 업그레이드</td><td>4.x 대에서 버그 경험</td><td>스테이징 환경 필수 테스트</td></tr></tbody></table><blockquote><p>버전 업그레이드는 반드시 스테이징 환경에서 충분히 검증한 뒤 프로덕션에 적용하자. 실제로 여러 차례 업그레이드/다운그레이드를 반복한 경험이 있다. 롤백 계획은 항상 준비해두어야 한다.</p></blockquote><h3 id=도입-체크리스트>도입 체크리스트<a hidden class=anchor aria-hidden=true href=#도입-체크리스트>#</a></h3><p><strong>배포 전</strong></p><ul><li><input disabled type=checkbox> 유스케이스와 요구사항 정의</li><li><input disabled type=checkbox> 데이터 볼륨 및 증가량 추정</li><li><input disabled type=checkbox> 테이블 모델 선택</li><li><input disabled type=checkbox> 파티션 전략 설계</li></ul><p><strong>배포 후</strong></p><ul><li><input disabled type=checkbox> Routine Load 작업 생성 및 검증</li><li><input disabled type=checkbox> 사용자 권한 설정</li><li><input disabled type=checkbox> 데이터 보관 정책(TTL) 설정</li><li><input disabled type=checkbox> Scale-in/out 절차 문서화</li><li><input disabled type=checkbox> 모니터링 대시보드 구성</li></ul><h2 id=마치며>마치며<a hidden class=anchor aria-hidden=true href=#마치며>#</a></h2><p>StarRocks 도입에서 얻은 핵심 교훈을 정리하면 다음과 같다.</p><ol><li><strong>Aggregate Key 모델이 핵심이다</strong> — 수집 시점 자동 집계로 스토리지와 쿼리 성능을 동시에 잡을 수 있다</li><li><strong>BITMAP_UNION으로 정확한 유니크 카운트를 확보하자</strong> — 비즈니스 KPI에는 근사치가 아닌 정확한 수치가 필요하다</li><li><strong>Routine Load + Aggregate Key 조합이 Flink를 대체한다</strong> — SQL만으로 실시간 집계 파이프라인을 구축할 수 있다</li><li><strong>운영 자동화에 투자하자</strong> — Materialized View와 Routine Load 모니터링은 필수다</li></ol><p>실시간 분석 워크로드에서 StarRocks는 파이프라인 복잡도를 획기적으로 줄여주는 강력한 선택지다. 다만 버전 업그레이드와 운영 안정성 측면에서는 아직 성숙해지는 과정에 있으므로, 충분한 PoC와 스테이징 검증을 거쳐 도입하길 권장한다.</p><p><strong>참고 자료</strong>: <a href=https://docs.starrocks.io>StarRocks 공식 문서</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://NhoSW.github.io/my-tech-blog/ko/tags/starrocks/>Starrocks</a></li><li><a href=https://NhoSW.github.io/my-tech-blog/ko/tags/olap/>Olap</a></li><li><a href=https://NhoSW.github.io/my-tech-blog/ko/tags/real-time/>Real-Time</a></li><li><a href=https://NhoSW.github.io/my-tech-blog/ko/tags/kafka/>Kafka</a></li><li><a href=https://NhoSW.github.io/my-tech-blog/ko/tags/performance-tuning/>Performance-Tuning</a></li><li><a href=https://NhoSW.github.io/my-tech-blog/ko/tags/data-pipeline/>Data-Pipeline</a></li></ul><nav class=paginav><a class=next href=https://NhoSW.github.io/my-tech-blog/ko/posts/starracks-compression-guide/><span class=title>다음 페이지 »</span><br><span>StarRocks 압축 설정 가이드: 성능과 스토리지 최적화</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기 on x" href="https://x.com/intent/tweet/?text=StarRocks%20%eb%8f%84%ec%9e%85%ea%b8%b0%3a%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20OLAP%ec%9c%bc%eb%a1%9c%20%eb%8d%b0%ec%9d%b4%ed%84%b0%20%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8%ec%9d%84%20%ed%98%81%ec%8b%a0%ed%95%9c%20%ec%9d%b4%ec%95%bc%ea%b8%b0&amp;url=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fko%2fposts%2fstarrocks-adoption-guide%2f&amp;hashtags=starrocks%2colap%2creal-time%2ckafka%2cperformance-tuning%2cdata-pipeline"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fko%2fposts%2fstarrocks-adoption-guide%2f&amp;title=StarRocks%20%eb%8f%84%ec%9e%85%ea%b8%b0%3a%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20OLAP%ec%9c%bc%eb%a1%9c%20%eb%8d%b0%ec%9d%b4%ed%84%b0%20%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8%ec%9d%84%20%ed%98%81%ec%8b%a0%ed%95%9c%20%ec%9d%b4%ec%95%bc%ea%b8%b0&amp;summary=StarRocks%20%eb%8f%84%ec%9e%85%ea%b8%b0%3a%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20OLAP%ec%9c%bc%eb%a1%9c%20%eb%8d%b0%ec%9d%b4%ed%84%b0%20%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8%ec%9d%84%20%ed%98%81%ec%8b%a0%ed%95%9c%20%ec%9d%b4%ec%95%bc%ea%b8%b0&amp;source=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fko%2fposts%2fstarrocks-adoption-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fko%2fposts%2fstarrocks-adoption-guide%2f&title=StarRocks%20%eb%8f%84%ec%9e%85%ea%b8%b0%3a%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20OLAP%ec%9c%bc%eb%a1%9c%20%eb%8d%b0%ec%9d%b4%ed%84%b0%20%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8%ec%9d%84%20%ed%98%81%ec%8b%a0%ed%95%9c%20%ec%9d%b4%ec%95%bc%ea%b8%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fko%2fposts%2fstarrocks-adoption-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기 on whatsapp" href="https://api.whatsapp.com/send?text=StarRocks%20%eb%8f%84%ec%9e%85%ea%b8%b0%3a%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20OLAP%ec%9c%bc%eb%a1%9c%20%eb%8d%b0%ec%9d%b4%ed%84%b0%20%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8%ec%9d%84%20%ed%98%81%ec%8b%a0%ed%95%9c%20%ec%9d%b4%ec%95%bc%ea%b8%b0%20-%20https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fko%2fposts%2fstarrocks-adoption-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기 on telegram" href="https://telegram.me/share/url?text=StarRocks%20%eb%8f%84%ec%9e%85%ea%b8%b0%3a%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20OLAP%ec%9c%bc%eb%a1%9c%20%eb%8d%b0%ec%9d%b4%ed%84%b0%20%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8%ec%9d%84%20%ed%98%81%ec%8b%a0%ed%95%9c%20%ec%9d%b4%ec%95%bc%ea%b8%b0&amp;url=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fko%2fposts%2fstarrocks-adoption-guide%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share StarRocks 도입기: 실시간 OLAP으로 데이터 파이프라인을 혁신한 이야기 on ycombinator" href="https://news.ycombinator.com/submitlink?t=StarRocks%20%eb%8f%84%ec%9e%85%ea%b8%b0%3a%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20OLAP%ec%9c%bc%eb%a1%9c%20%eb%8d%b0%ec%9d%b4%ed%84%b0%20%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8%ec%9d%84%20%ed%98%81%ec%8b%a0%ed%95%9c%20%ec%9d%b4%ec%95%bc%ea%b8%b0&u=https%3a%2f%2fNhoSW.github.io%2fmy-tech-blog%2fko%2fposts%2fstarrocks-adoption-guide%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://NhoSW.github.io/my-tech-blog/ko/>OTL - 데이터 엔지니어링</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>